はい、承知いたしました。ご提供いただいたPDFのコピーペーストを、体裁を整えて文字起こしします。

-----

### §5.1 オシロスコープの波形を取り込もう

いくつかの設定が必要となる。なおこの設定は文献 [4] を参考にした。

#### §5.1.1 USB 使用権を設定

一般のユーザーでも USB 機器を利用できるようにする。ターミナルを開いて以下を実行する。

```bash
sudo su
echo 'SUBSYSTEM=="usb", MODE="0666", GROUP="usbusers"' >> /etc/udev/rules.d/99-com.rules
exit
```

**（注：`echo`の行は改行せずに入力する）**

ポートのルールファイル (`99-com.rules`) にすべてのユーザーが使えるように設定します。その前の「`sudo su`」は root 権限でコマンドを実行できるようにするためのものです。そのあと Raspberry Pi を再起動 (`reboot`) する。

#### §5.1.2 VISA 用ライブラリを追加

ターミナル上で仮想環境に移行します。

```bash
cd sato
source venvdir/bin/activate
```

仮想環境上で `pip install` コマンドにより `pyvisa`, `pyvisa-py`, `pyusb` の 3 つのライブラリをインストールする。

#### §5.1.3 認識の確認

Rasberry Pi とオシロスコープ (Rigol DHO914) を USB ケーブルで接続する。Rasberry Pi 側は USB-A を、オシロスコープ側は背面の USB-B のポート (図 5) をつかう。⁵

\<br\>
\<center\>
図 5: オシロスコープ背面の右上にある USB ポート
\</center\>
\<br\>

Thonny を起動し、以下のプログラム (`checkResourceManager.py`) を実行する。

**リスト 4: checkResourceManager.py**

```python
import pyvisa

rm = pyvisa.ResourceManager()
visaList = rm.list_resources()
print(visaList)
```

このとき Raspberry Pi の pyvisa から認識されている機器のリソース名のリストが表示される。そのなかに
`'USB0::6833::1100::DHO9S262702748::0::INSTR'`
のように装置 (USB0 のポートに DHO9 で始まる名前の装置) が含まれていれば認識されている可能性が高い。そのうえで、以下のプログラムを実行する。

**リスト 5: checkResourceManager2.py**

```python
import pyvisa

rm = pyvisa.ResourceManager()
visaList = rm.list_resources()
print(visaList)

# '****'の中には先に実行した時に表示されたオシロスコープと思しきリソース名を入れる。
# 例：
# inst = rm.open_resource('USB0::6833::1100::DHO9S262702748::0::INSTR')
inst = rm.open_resource('****') 

# *IDN? はVISA規格共通のコマンドで装置の名前、型番を尋ねるコマンド。
print(inst.query("*IDN?"))
```

`*IDN?` の結果に型番の DHO914 が入っていれば通信ができている。

以上がもっとも単純な通信のテストである。通信が確立できていることが確認できればなにかうまく行かない点があっても通信以外の原因だと推測がしやすい。

-----

## **課題 24.** 上記の操作を実際に行い、通信ができることを確かめよう。うまく行かない場合、Rasberry pi 本体およびオシロスコープの再起動が必要な場合もある。

上記では `ResourceManager` から `open` した `inst` のメソッドとして `query` を使っているがこれは、`*IDN?` が、機器から何らかの応答が期待されるコマンド (機器の名前を尋ねて、その名前が返ってくる) だからである。`query` 以外にも、一方通行で命令を送るだけの `write`、情報をもらうだけの `read` などがある。これらは、ASCII データ (テキストデータ) でやりとりされ、人間にとって読みやすいがデータ量が大きくなる。測定データのように比較的容量の大きいデータの送受信にはバイナリデータをあつかう、`query_binary_values` もあるがデータ型の指定やその長さの指定なども必要となる。

また、上では VISA のコマンドとして `*IDN?` を上げているがこれは共通コマンドと呼ばれているコマンドである。VISA の規格に準拠した機器であれば、このコマンドを認識する。それ以外にも機器を制御するための独自のコマンドがある。これらのコマンドは装置のプログラミングガイドに詳細が記載されている [5] が全てを理解する必要はなく、必要に応じて機能を探す形で十分な場合が多い。表 1 に、波形の取得に必要なコマンドの一例を示す。

-----

⁵ ここでは詳しく触れないが「VISA 通信」というキーワードで調べるとより詳しい解説が見つかる。

### §5.2 波形を表示させよう

次に実際にオシロスコープと通信しデータを取得する。一口にオシロスコープのデータといっても、画面に表示されている画像データ、測定のための設定情報、表示している波形データであるがここでは、表示されている波形を Raspberry Pi に取り込む。

まず、オシロスコープ上に取り込みたいデータを表示させる。ここでは以下の手順で発振器 (KENWOOD, AG-203D) から正弦波の波形信号を表示させる。

1.  オシロスコープの ch1 と発信器の OUTPUT を BNC ケーブルで接続する。
2.  発信器とオシロスコープの電源を ON にする。発信器の操作パネルの使い方は、次の通りである。
      * 「Frequency」と「RANGE」で、発振周波数を変える。
      * 「Attenuator」と「Amplitude」で、振幅を変える。ただし、「Attenuator」は -10dB に固定しておく。
      * 「Waveform」ボタンで、正弦波と矩形波を選択する。
3.  発信器は、電源を入れただけで、すでに発信して、波形を出力しているはずである。以下の操作で、オシロスコープに波形が表示されるようになってから、上記の発信条件を変えて、波形の変化を観察する。
4.  オシロスコープ上で波形が安定して表示されていることを確認する。

-----

**課題 25.** 上の方法で画面上に正弦波を表示させよう。そのときの波形の特徴を記録しよう。例：振幅、周期、オフセット

## **課題 26.** リスト 5 のあとに 6 をを追加して、測定モードが Rasberry Pi から切り替えられることを確認しよう

**リスト 6: シングルショットモードへの切り替え**

```python
inst.write(':SINGle')
```

**表 1: オシロスコープの制御に使う VISA コマンドの例**

| コマンド | 役割 | 使用例 |
| --- | --- | --- |
| **共通コマンド** | | |
| `*IDN?` | 装置の名前、型番を返す。 | `inst.query('*IDN?')` |
| `*OPC?` | 直前の命令が完了しているかどうかを返す。戻り値が 1 の場合、完了している。 | `inst.query('*OPC?')` |
| **デジタルオシロスコープ DHO914 独自コマンド** | | |
| `:RUN` | 測定開始命令。オシロスコープの RUN ボタンと同じ機能。 | `inst.write(':RUN')` |
| `:SINGle` | シングルシーケンス測定 (設定後トリガーがかかった最初のデータを画面に表示) に設定。 | `inst.write(':SINGle')` |
| `WAVeform:POINts?` | 波形データのデータ数を取得 | `inst.query('WAVeform:POINts?')` |
| `:WAVeform:FORMat [形式]` | データ送信時の形式を指定。`WORD`(16bit データ), `BYTE`(8bit データ), `ASCii`(, 区切りテキストデータ) が指定可能。 | `inst.write(':WAVeform:FORMat BYTE')` |
| `:WAVeform:MODE [モード]`| `:WAVeform:DATA?`コマンドで送信されるデータのモードを設定。`NORMal`,`MAXimum`,`RAW` が指定可能。通常 `NORMal` で問題ない。詳細は文献 [5] 参照のこと | `inst.write(':WAVeform:MODE NORMal')` |
| `:WAVeform:SOURce [データソース]` | 送信するチャネルを指定。`CHAN1`, `CHAN2`, `CHAN3`, `CHAN4`, `MATH1` など指定可能。 | `inst.write(':WAVeform:SOURce CHANnel1')` |
| `:WAVeform:DATA?` | `:WAVeform:SOURce` でしたデータを送信。`:WAVeform:FORMat` で `WORD`,`BYTE` を指定した場合はバイナリデータで送信される。| `inst.query_binary_values(':WAVeform:DATA?', datatype='B', container=list, chunk_size=acq_record*1)` |

つぎに表 1 のコマンドを使ってデータを取得する例をリスト 7 に示す。

**リスト 7: Oscilloscope\_Rigol\_waveread\_02.py**

```python
# Rigol DHO924Sとの通信
import pyvisa
import time

rm = pyvisa.ResourceManager()
visaList = rm.list_resources()
print(visaList)

if len(visaList) > 0:
    print(visaList[0])
    # inst = rm.open_resource('USB0::6833::1100::DHO9S262702748::0::INSTR')
    inst = rm.open_resource(visaList[0])
    print(inst)
    result = inst.query("*IDN?")
    print(result)
    inst.timeout = 10000 #ms

    # シングルショット測定に設定
    inst.write(':SINGle') 
    # 測定が終了していると1が表示される
    r = inst.query('*OPC?')
    print(r) 

    # ch1の波形を取得できるように設定
    inst.write(':WAVeform:SOURce CHANnel1') 
    inst.write(':WAVeform:MODE NORMal')
    # バイナリデータで送信
    inst.write(':WAVeform:FORMat BYTE') 
    # データ点数を取得
    acq_record = int(inst.query('WAVeform:POINts?')) 
    print(acq_record)
    # datatype: struct moduleより b: signed char, B: unsigned char
    # chunk_size: 送信されるデータの長さ(Byte) = データ数 x 1点当たりのデータ量(1Byte)
    binwave1 = inst.query_binary_values(':WAVeform:DATA?', datatype='B', 
                                        container=list, chunk_size=acq_record*1)

    # シングルショット測定にしていたのを自動測定に変更
    inst.write(':RUN') 
    # instのインスタンスを閉じる
    inst.close() 

# rmのインスタンスを閉じる
rm.close() 

# データを確認
print(len(binwave1)) 
```

-----

**課題 27.** リスト 7 を参考にしてオシロスコープから波形データを取得してみよう。

## **課題 28.** さらに、プログラムを改造し測定したデータをグラフに表示するプログラムを作ろう。可能であれば縦軸、横軸のラベルも正しく表示できるようにしよう。 ヒント: 参考文献 [5] p.402-425 の以下のコマンドを参照のこと。 横軸：`:WAVeform:XINCrement?`, `:WAVeform:XORigin?`, `:WAVeform:XREFerence?` 縦軸：`:WAVeform:YINCrement?`, `:WAVeform:YORigin?`, `:WAVeform:YREFerence?`

### §5.3 波形データの保存

測定したデータは Rasberry Pi 内に保存することも可能である。オシロスコープのデータを保存する前に配列データを保存する手法をここでは見る。ファイルの出力については「Python 本」4-3 を参照のこと。

リスト 8 にオシロスコープで取得したデータに見立てて $sin$ 関数を配列に保持し、それをデータとして保存するプログラムを示す。

-----

## **課題 29.** 各自のホルダーに data 保存用のディレクトリ”data”を作成しリスト 8 を実行してみよう。data ディレクトリ内に test\_01.txt ができていれば thonny で開いてみて内容を確認しよう。

**リスト 8: data\_save\_01.py**

```python
# データ保存の例
import math

Nmax = 100
x: list[float] = [] 
y: list[float] = []
# x = [] や y = [] と変わらないがなんのリストか明示することで警告を防げる

# sin関数の波形を保存用のデータとしてリストを作る
for i in range(Nmax):
    # リストに新たな要素**を追加するときは"+"で長さ1のリスト[**]を連結
    x = x + [i * (1.0 / Nmax) * 2 * math.pi]
    y = y + [math.sin(x[i])]

# 必要に応じてコメントアウトを外して動作を確認しよう
# print(x)
# print(y)

# 書き込み内容を一時保存する文字列s
s = ""
for i in range(len(x)):
    # print(i)
    # 文字列にリストの内容を1行ずつ書き込む
    s += "{0:<.5f}\t{1:<.5f}\n".format(x[i], y[i])

# 文字列の内容確認
print(s) 

f = open("../data/test_01.txt", "w")
# 文字列の内容をファイルに書き込む
f.write(s) 
f.close()
```

-----

**課題 30.** リスト 8 の 23 行目を以下のように書き換えて何が変わるか確かめよう。

  * `s += "{0:<.2f}\t{1:<.2f}\n".format(x[i], y[i])`
  * `s += "{0:<.5f}, {1:<.5f}\n".format(x[i], y[i])`
  * `s += "{0:<.5f}\t{1:<.5f}\n".format(y[i], x[i])`

**課題 31.** python の文字列の形式操作メソッド `.format` について調べ、指数表示 (例:2.98e+8) などのそのほかの保存形式を調べよう。「Python 本」2-3 を参考にするとよい

## **課題 32.** オシロスコープの波形データをテキストデータで保存するプログラムを作ろう。

### §5.4 データを自動的に解析しよう

測定したデータは計算機を使うことで解析の自動化も可能である。
オシロスコープで、正弦波を測定していることから取得した波形は

$$Y = A \sin(2\pi f t + \phi) + C \quad (1)$$

にとしたとき、関数の特徴として $A$ 振幅 (V)、$f$ 周波数 (Hz)、$\\phi$ 位相 (rad)、$C$ オフセット (V) を持っている。諸君は、経験上、波形データを与えられたときそこからこれらの特徴量を抽出することができるはずだ。実際に課題 25 ではそれらを記録してもらった。データのどのような特徴をつかえば、python を使ってそれらは求められるだろうか？この問いの答えを、まずは考えたうえで次の課題に取り組んでほしい。

-----

**課題 33.** オシロスコープで測定した波形データから振幅を求めるプログラムを作ろう

**課題 34.** オシロスコープで測定した波形データからそのほかの特徴量も求めるプログラムを作り課題 25 の結果と比較しよう

**課題 35.** 信号発生器の周波数、出力減衰を切り替えて正しく動作するか確認しよう。

**課題 36.** 一般に測定データにはノイズが加わっている。特徴量の抽出の仕方として、どのような工夫をするとノイズの影響を受けにくいだろうか。

## **課題 37.** オシロスコープで測定した波形データをフーリエ変換し、上の特徴量を求めるプログラムを作ろう。フーリエ変換はライブラリを探して導入してもよいし自身で計算するプログラムを作ってもよい。

### §6 センサー・モジュール利用のための前準備

ここまで、Rasberry Pi とブレッドボードの回路は、Rasberry Pi 上のコネクタに直接ジャンパ線を差し込んで接続してきた。それだと Raspberry Pi に装着している冷却ファンの陰になって端子名が読み取りにくかったり細かい作業に支障をきたすこともあった。

ここからは T 字拡張ボートと 40pinGPIO ケーブル (リボンケーブル) を用いて Rasbrry Pi とブレッドボードを図 6 のように接続する。これにより各端子の識別がしやすくなる。

\<br\>
\<center\>
図 6: T 字拡張ボートと 40pinGPIO ケーブルで接続した Raspberry Pi とブレッドボード
\</center\>
\<br\>

「ラズパイガイド」P.248, p.249 の端子と T 字拡張ボードの各端子を見比べるとそれぞれが対応していることがわかる。

-----

## **課題 38.** 図 6 のように接続し、以前行った LED 点灯回路が動くことを確認しよう。動かない場合 GPIO ケーブルが逆に刺さっていないか確認しよう。

### §7 タイミングの制御

ここでは、超音波距離センサの利用を通して Python を使た時間測定手法を習得しよう。

#### §7.1 超音波距離センサを使おう

##### §7.1.1 超音波距離センサ HC-SR04

何はともあれ超音波距離センサーを使うことから始める。超音波距離センサ (図 7) は、送信用 (Transmitter) の超音波スピーカーと受信用 (Reciever) の超音波マイク (恐らく同一のもの) が左右についている。スピーカーからパルス的に出力される 40 kHz の超音波が物体にあたって反射して帰ってくるまでの時間 (Time of Flight) から距離を測定する。本節ではこの時間をプログラムを使って求める。

このような原理に則った距離センサを Time of Flight の略称から ToF センサまたは単に ToF と呼ぶこともある。なお、超音波以外にもパルスレーザーを用いた ToF センサも存在するがそれぞれ得意とする測距範囲や精度が異なる。

\<br\>
\<center\>
図 7: 超音波距離センサ HC-SR04
\</center\>
\<br\>

##### §7.1.2 配線

超音波距離センサの端子は 4 つあり、スピーカーがついている側からみて左から順番にピン番号 1 から 4 が割り当てられている。それぞれ順番に Vcc, Trig, Echo, Gnd という名前がついている。このうち Vcc は電力供給用の端子であり、3 から 5.5V の電圧供給があれば動作する。Gnd はセンサモジュール全体の接地用に用いる。センサモジュールをブレッドボードに各端子が導通しないように刺す場所を選んで差し込む (図 8)。

**注意:** 誤動作を避けるため電源投入に当たる Vcc の接続は最後に行うこと

\<br\>
\<center\>
図 8: 超音波距離センサの配線
\</center\>
\<br\>

配線が完了したらリスト 9 のプログラムを作成し実行してみよう。

**リスト 9: DistanceSensor\_01.py**

```python
from gpiozero import DistanceSensor
from time import sleep

sensor = DistanceSensor(echo=24, trigger=23)

try:
    while True:
        distance = sensor.distance * 1000
        print('Distance: {:.2f} mm'.format(distance))
        sleep(0.1)

except KeyboardInterrupt:
    pass
```

うまく行くとキーボードを推すまでコンソールに距離が定期的に表示される。

-----

## **課題 39.** スピーカーの前に障害物をおいて距離を測ってみよう。実際の距離とセンサーで読み取った距離に違いはあるだろうか？何点か距離を替えて測定し横軸実際の距離縦軸センサーで読み取った距離としてどれぐらいの範囲で測定可能か調べてみよう。

リスト 9 のプログラムでは、gpiozero の中に距離センサー用のライブラリ `DistanceSensor` がすでに入っており、どのように距離を測っているのかはブラックボックスに入っていてわからない。

gpiozero のコードは公開されている⁶ ことからそれを調べるという方法もあるが実際読み取ろうとすると初心者にはわかりにくい点が多々出てくる。
そこでデータシートをみながら動作を確認し、それに基づいてプログラムを構築する。

-----

⁶ [https://gpiozero.readthedocs.io/en/latest/api\_input.html\#distancesensor-hc-sr04](https://gpiozero.readthedocs.io/en/latest/api_input.html#distancesensor-hc-sr04)

### §7.2 データシートをみてみよう

データシートは、製品が持つ機能や仕様をまとめた資料で、使い方が書かれている取扱説明書とは異なる。センサーモジュールや測定機器などの製品ごとに存在し装置の選定や動作確認に必要となる。最近では、紙媒体ではなく、web からダウンロードできるようにしている製品も多い。

HC-SR04 についての資料はインターネット上を探すといろいろな資料が見つかるが文献 [6, 7] がデータシートとしてまとまっている。

文献 [6] の 2 ページ目には、このモジュールのタイミング図が書かれている。この図は横軸が時間、縦軸がデジタル信号の High, もしくは Low を表している。これを見るとまず Trig 端子に 10 µs のパルスが入ると、スピーカー (Transmitter) から超音波 (40kHz, 8 周期) が送信される。Echo 端子は、超音波の放出が終了すると High となり、物体にあたった超音波がマイク (Reciever) で受信されると、Low になる。つまり、Echo 信号のパルスが High になっている時間が、超音波が空気中を伝搬している時間を反映している⁷。

\<br\>
\<center\>
図 9: 距離センサーのタイミング図とその解釈。文献 [6] より
\</center\>
\<br\>

-----

⁷ 厳密には超音波のパルス幅の議論やどうなれば、超音波が返ってきたと判断されるかの議論が必要

### §7.3 センサからの信号をオシロスコープで観察しよう

ここでは図 9 でみた Trig 入力信号と Echo 端子出力信号をオシロスコープで観察しデータシートに書かれていることを理解する。

-----

## **課題 40.** リスト 9 のプログラムを用い距離をはかるプログラムを動かしながら Trig への入力信号、Echo 端子からの出力端子の信号を観察できるように配線しよう。観察にはオシロスコープ用のプローブを用いるとよい。プローブの GND(ワニ口クリップ) とブレッドボードの GND ラインは結線すること。

\<br\>
\<center\>
図 10: 信号の測定例。ここでは Trig、Echo と同時に Transmitter、Reciever に電極を付けることでそれぞれの信号も取得している。
\</center\>
\<br\>

-----

**課題 41.** オシロスコープとの通信を行って Echo 端子の波形を記録するプログラムを作ろう

**課題 42.** 波形データを解析して Echo からの出力の High の持続時間 $\\tau$ を求めるプログラムを作ろう

## **課題 43.** 文献 [6] によると、物体までの距離 $d$ は、音速 $v = 340 , \\text{(m/s)}$ を用いて $$d = \tau v / 2 \quad (2)$$ とかける。これはどの程度正しいだろうか。物体までの距離を変えて調べてみよう。

### §7.4 時間計測

上では、波形取得後に Echo の持続時間を調べることを行った。ここでは、Rasberry Pi の持つタイマーを使って `gpiozero` の `DistanceSensor` のライブラリをあえて使わずに距離計測を行う。

#### §7.4.1 パルスの生成

トリガー信号の生成には10µsのパルスを信号作る必要がある。パルスを作るのに `gpiozero.DigitalOutputDevice()` をつかってはじめ `off()` にしておいたポートを `on()` にし、10µs 後に `off()` に戻せばよい。10µs の時間を測るにはたとえば `time` ライブラリの `time.sleep()` 関数が利用可能である。

-----

## **課題 44.** 周期的に 10µs のパルスを発生するプログラムを作り、オシロスコープでパルスが生成できていることを確かめよう

#### §7.4.2 時間の計測

次に Echo 信号が high になっている持続時間を測りたい。時刻を取得する関数として `time` ライブラリの `time.perf_counter()` 関数⁸が有用である。この関数は、システム (OS) が持っている時刻をミリ秒単位で返す。ただし、相対的にしか意味を持たない。つまり、2 回実行することでその値の差が意味を持つ。たとえば

```python
import time

time1 = time.perf_counter()
# (何らかの処理)
time2 = time.perf_counter()

print(time2 - time1)
```

とすることで (何らかの処理) にかかった時間を測ることができる。

-----

**課題 45.** (何らかの処理) のところに `sleep()` 関数による待機を入れ時間が図れるか試してみよう

**課題 46.** タクトスイッチの ON/OFF 状態を取得する回路を作り、ボタンの長押ししている時間を調べるプログラムを作ろう。
難しい場合、以下のようなプログラムを考えてみよう.

```python
# ボタンがLowである限り時刻を取得し、start_timeに時刻を代入し続ける。ボタンがHighになるとループを抜ける
while ボタンの状態 == Low:
    start_time = time.perf_counter()
# ボタンがHighである限り時刻を取得し、end_timeに時刻を代入し続ける。ボタンがHighになるとループを抜ける
while ボタンの状態 == High:
    end_time = time.perf_counter()

押されている時間 = end_time - start_time
```

## 【発展】「電子工作本」5.5.2 では gpiozero の Button クラスでボタンが押された時のコールバック関数を `when_pressed` に設定できた。同様に離された時のイベント発生時のコールバック関数は `when_released` で指定できる。余力のある人はイベントを用いたボタン押下時間の取得方法を考えてみよう。

#### §7.4.3 距離計測

ここまでで、10 マイクロ秒のパルス発生、ボタンが ON になっている持続時間の計測ができるようになった。

-----

**課題 47.** 超音波距離センサーに戻って、`gpiozero` の `DistanceSensor` クラスを使わずに距離を取得するプログラムを作ろう。

## **課題 48.** 衝突安全装置を作ろう。近代的な自動車にはセンサーがついており、周囲に障害物があると音でドライバーに知らせてくれる。距離センサーを使ってある一定距離に物体が近づいたら何らかの警告を出す装置を作ろう。